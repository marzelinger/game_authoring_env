/**
 * This class is used to build the parse tree out of the list of tokens generated by the Tokenizer. Nodes have children and parents. The abstract Node class is directly extended by many specific node classes such as SumNode or DifferenceNode. It is also extended by the abstract ExecutableNode class which is also extended by the abstract StructuredNode class. These nodes implement an execute function that return consumers in order to operate on turtles. All nodes implement an evaluate function which return their value based on their token and children.
 *
 * @author mpz5
 */

package Compiler.TokenParser.Nodes;

import Compiler.TokenParser.Token;
import Compiler.TokenParser.TokenType;

import java.util.ArrayList;
import java.util.List;

/**
 * Node class will be extended by Nodes of different token types. Every Node should track its own children.
 */
public abstract class Node {

    private List<Node> children;
    private Token token;
    private Node parent;

    public Node(Token t) {
        children = new ArrayList();
        token = t;
    }

    /**
     * This function determines if a node is a child of a ListStartNode and is used for syntax checking.
     * @return
     */
    public boolean checkInsideList(){
        if(parent!=null){
            return parent.checkType(TokenType.ListStart);
        }
        return false;
    }

    /**
     * This is a private function used to set the parent of a node when it is added to the childrens list for another.
     * @param parent
     */
    private void setParent(Node parent){
        this.parent = parent;
    }

    /**
     * Returns the string that the token value was based on.
     * @return
     */
    public String getTokenValue(){
        return token.getValue();

    }

    /**
     * This function is used to print out nodes, largely for debugging purposes for the backend.
     * @return
     */
    public String toString(){
        return getTokenValue() + ": " + getChildren().toString();
    }

    /**
     * Getter for the ArrayList of children. This is used to iterate through the parse tree in the Executer class as well as in many of the Node subclasses when executing and/or evaluating a node.
     * @return
     */
    public List<Node> getChildren(){
        return children;
    }

    public void addChild(Node newChild){
        children.add(newChild);
        newChild.setParent(this);
    }

    /**
     * This function compares the type of this node to that of another Node.
     * @param comparisonType
     * @return
     */
    public boolean checkType(TokenType comparisonType){
        return token.checkTypeEquality(comparisonType);
    }

    /**
     * The purpose of this function is to get the correct return value of the node. This will be the final number that the node evaluates to, and will not execute instructions.
     * @return
     */
    public abstract double evaluate();

    /**
     * Determines if this node is a structured Node. This is used on Node subclasses to determine if they extend the StructuredNode class and determine if syntax checking is necessary.
     * @return
     */
    public boolean checkStructured(){
        return token.checkStructured();
    }

    /**
     * Determines if this node is an ExecutableNode. This is used on Node subclasses to determine if they extend the ExecutableNode class and determine if the execute function can be called.
     * @return
     */
    public boolean checkExecutable(){
        return token.checkExecutable();
    }

    /**
     * This determines if a a node is
     * @return
     */
    public boolean checkInsideFunctionDefinition(){
        return parent!=null && parent.checkType(TokenType.MakeUserInstruction);
    }

    public int getNumArgs(){
        if(checkType(TokenType.Command)){
            return ((CommandNode)this).getCommandNumArgs();
        }
        return token.getNumArgs();
    }

}
